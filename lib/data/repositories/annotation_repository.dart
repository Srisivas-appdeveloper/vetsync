import 'dart:convert';
import 'package:drift/drift.dart';
import 'package:get/get.dart' hide Value;
import 'package:uuid/uuid.dart';

import '../models/models.dart';
import '../services/api_service.dart';
import '../services/database_service.dart';
import '../services/connectivity_service.dart';
import '../services/sync_service.dart';
import '../../core/constants/app_config.dart';

/// Annotation repository
class AnnotationRepository {
  final ApiService _api = Get.find<ApiService>();
  final DatabaseService _database = Get.find<DatabaseService>();
  final ConnectivityService _connectivity = Get.find<ConnectivityService>();
  final SyncService _sync = Get.find<SyncService>();
  final Uuid _uuid = const Uuid();

  /// Create annotation
  Future<Annotation> createAnnotation({
    required String sessionId,
    required DateTime timestampUtc,
    required int elapsedMs,
    required SessionPhase phase,
    required AnnotationCategory category,
    required String type,
    String? description,
    AnnotationSeverity severity = AnnotationSeverity.info,
    Map<String, dynamic>? structuredData,
    String? voiceNotePath,
    String? voiceTranscription,
    required String annotatorUserId,
    bool isAutoGenerated = false,
  }) async {
    final annotationId = _uuid.v4();

    final annotation = Annotation(
      id: annotationId,
      sessionId: sessionId,
      timestampUtc: timestampUtc,
      elapsedMs: elapsedMs,
      phase: phase,
      category: category,
      type: type,
      description: description,
      severity: severity,
      structuredData: structuredData,
      voiceNotePath: voiceNotePath,
      voiceTranscription: voiceTranscription,
      annotatorUserId: annotatorUserId,
      isAutoGenerated: isAutoGenerated,
      createdAt: DateTime.now(),
      syncStatus: SyncStatus.pending,
    );

    // Save to local database
    await _database.db.insertAnnotation(
      LocalAnnotationsCompanion(
        id: Value(annotationId),
        sessionId: Value(sessionId),
        timestampUtc: Value(timestampUtc),
        elapsedMs: Value(elapsedMs),
        phase: Value(phase.value),
        category: Value(category.value),
        type: Value(type),
        description: Value(description),
        severity: Value(severity.value),
        structuredDataJson: Value(
          structuredData != null ? jsonEncode(structuredData) : null,
        ),
        voiceNotePath: Value(voiceNotePath),
        voiceTranscription: Value(voiceTranscription),
        annotatorUserId: Value(annotatorUserId),
        isAutoGenerated: Value(isAutoGenerated),
        syncStatus: const Value('pending'),
      ),
    );

    // Try to sync to server
    if (_connectivity.isOnline.value) {
      try {
        final response = await _api.post(
          ApiEndpoints.sessionAnnotations(sessionId),
          data: annotation.toJson(),
        );
        await _database.db.updateAnnotationSyncStatus(annotationId, 'synced');
        return Annotation.fromJson(response.data as Map<String, dynamic>);
      } catch (e) {
        print('Annotation sync failed, will retry: $e');
      }
    }

    return annotation;
  }

  /// Save annotation from Annotation object
  Future<Annotation> saveAnnotation(Annotation annotation) async {
    return createAnnotation(
      sessionId: annotation.sessionId,
      timestampUtc: annotation.timestampUtc,
      elapsedMs: annotation.elapsedMs,
      phase: annotation.phase,
      category: annotation.category,
      type: annotation.type,
      description: annotation.description,
      severity: annotation.severity,
      structuredData: annotation.structuredData,
      voiceNotePath: annotation.voiceNotePath,
      voiceTranscription: annotation.voiceTranscription,
      annotatorUserId: annotation.annotatorUserId,
      isAutoGenerated: annotation.isAutoGenerated,
    );
  }

  /// Create physiological event annotation
  Future<Annotation> createPhysiologicalEvent({
    required String sessionId,
    required DateTime timestampUtc,
    required int elapsedMs,
    required SessionPhase phase,
    required PhysiologicalEventType eventType,
    required EventSeverityLevel severityLevel,
    required String annotatorUserId,
    String? notes,
    bool producedSample = false,
  }) async {
    return createAnnotation(
      sessionId: sessionId,
      timestampUtc: timestampUtc,
      elapsedMs: elapsedMs,
      phase: phase,
      category: AnnotationCategory.physiological,
      type: eventType.displayName,
      description: notes,
      severity: eventType.isCritical
          ? AnnotationSeverity.critical
          : AnnotationSeverity.info,
      structuredData: {
        'event_type': eventType.value,
        'severity_level': severityLevel.value,
        'produced_sample': producedSample,
        if (notes != null) 'notes': notes,
      },
      annotatorUserId: annotatorUserId,
    );
  }

  /// Create collar swap annotation
  Future<Annotation> createCollarSwapAnnotation({
    required String sessionId,
    required DateTime timestampUtc,
    required int elapsedMs,
    required SessionPhase phase,
    required String previousCollarId,
    required String newCollarId,
    required String reason,
    required int gapDurationMs,
    required String annotatorUserId,
  }) async {
    return createAnnotation(
      sessionId: sessionId,
      timestampUtc: timestampUtc,
      elapsedMs: elapsedMs,
      phase: phase,
      category: AnnotationCategory.system,
      type: 'Collar Swap',
      description: reason,
      severity: AnnotationSeverity.warning,
      structuredData: {
        'previous_collar_id': previousCollarId,
        'new_collar_id': newCollarId,
        'reason': reason,
        'gap_duration_ms': gapDurationMs,
      },
      annotatorUserId: annotatorUserId,
      isAutoGenerated: true,
    );
  }

  /// Create battery warning annotation
  Future<Annotation> createBatteryWarningAnnotation({
    required String sessionId,
    required DateTime timestampUtc,
    required int elapsedMs,
    required SessionPhase phase,
    required String collarId,
    required int batteryPercent,
    required String annotatorUserId,
  }) async {
    String warningLevel;
    AnnotationSeverity severity;

    if (batteryPercent <= 5) {
      warningLevel = 'emergency';
      severity = AnnotationSeverity.critical;
    } else if (batteryPercent <= 10) {
      warningLevel = 'critical';
      severity = AnnotationSeverity.critical;
    } else if (batteryPercent <= 20) {
      warningLevel = 'low';
      severity = AnnotationSeverity.warning;
    } else {
      warningLevel = 'warning';
      severity = AnnotationSeverity.info;
    }

    return createAnnotation(
      sessionId: sessionId,
      timestampUtc: timestampUtc,
      elapsedMs: elapsedMs,
      phase: phase,
      category: AnnotationCategory.system,
      type: 'Battery Warning',
      description: 'Battery at $batteryPercent%',
      severity: severity,
      structuredData: {
        'collar_id': collarId,
        'battery_percent': batteryPercent,
        'warning_level': warningLevel,
      },
      annotatorUserId: annotatorUserId,
      isAutoGenerated: true,
    );
  }

  /// Create phase transition annotation
  Future<Annotation> createPhaseTransitionAnnotation({
    required String sessionId,
    required DateTime timestampUtc,
    required int elapsedMs,
    required SessionPhase fromPhase,
    required SessionPhase toPhase,
    required String annotatorUserId,
  }) async {
    return createAnnotation(
      sessionId: sessionId,
      timestampUtc: timestampUtc,
      elapsedMs: elapsedMs,
      phase: toPhase,
      category: AnnotationCategory.system,
      type: 'Phase Transition',
      description:
          'Transitioned from ${fromPhase.displayName} to ${toPhase.displayName}',
      severity: toPhase == SessionPhase.surgery
          ? AnnotationSeverity.warning
          : AnnotationSeverity.info,
      structuredData: {
        'from_phase': fromPhase.value,
        'to_phase': toPhase.value,
      },
      annotatorUserId: annotatorUserId,
      isAutoGenerated: true,
    );
  }

  /// Get annotations for session
  Future<List<Annotation>> getSessionAnnotations(String sessionId) async {
    if (_connectivity.isOnline.value) {
      try {
        final response = await _api.get(
          ApiEndpoints.sessionAnnotations(sessionId),
        );
        return (response.data['annotations'] as List)
            .map((json) => Annotation.fromJson(json as Map<String, dynamic>))
            .toList();
      } catch (e) {
        return _getLocalAnnotations(sessionId);
      }
    }
    return _getLocalAnnotations(sessionId);
  }

  Future<List<Annotation>> _getLocalAnnotations(String sessionId) async {
    final local = await _database.db.getSessionAnnotations(sessionId);
    return local.map(_localToAnnotation).toList();
  }

  /// Update annotation
  Future<void> updateAnnotation(String id, Map<String, dynamic> updates) async {
    if (_connectivity.isOnline.value) {
      await _api.patch(ApiEndpoints.annotation(id), data: updates);
    } else {
      await _sync.queueForSync(
        entityType: 'annotation',
        entityId: id,
        action: 'update',
        data: updates,
        priority: 3,
      );
    }
  }

  /// Delete annotation
  Future<void> deleteAnnotation(String id) async {
    if (_connectivity.isOnline.value) {
      await _api.delete(ApiEndpoints.annotation(id));
    } else {
      await _sync.queueForSync(
        entityType: 'annotation',
        entityId: id,
        action: 'delete',
        data: {},
        priority: 3,
      );
    }
  }

  Annotation _localToAnnotation(LocalAnnotation local) {
    return Annotation(
      id: local.id,
      sessionId: local.sessionId,
      timestampUtc: local.timestampUtc,
      elapsedMs: local.elapsedMs,
      phase: SessionPhase.fromString(local.phase),
      category: AnnotationCategory.fromString(local.category),
      type: local.type,
      description: local.description,
      severity: AnnotationSeverity.fromString(local.severity),
      structuredData: local.structuredDataJson != null
          ? jsonDecode(local.structuredDataJson!) as Map<String, dynamic>
          : null,
      voiceNotePath: local.voiceNotePath,
      voiceTranscription: local.voiceTranscription,
      annotatorUserId: local.annotatorUserId,
      isAutoGenerated: local.isAutoGenerated,
      createdAt: local.createdAt,
      syncStatus: SyncStatus.fromString(local.syncStatus),
    );
  }
}
