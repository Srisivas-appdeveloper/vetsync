import 'dart:io';
import 'package:drift/drift.dart';
import 'package:drift/native.dart';
import 'package:get/get.dart' hide Value;
import 'package:path_provider/path_provider.dart';
import 'package:path/path.dart' as p;

part 'database_service.g.dart';

// ============================================================
// Table Definitions
// ============================================================

/// Local sessions table
class LocalSessions extends Table {
  TextColumn get id => text()();
  TextColumn get sessionCode => text()();
  TextColumn get animalId => text()();
  TextColumn get collarId => text()();
  TextColumn get observerId => text()();
  TextColumn get clinicId => text()();
  TextColumn get currentPhase => text()();
  TextColumn get surgeryType => text().nullable()();
  TextColumn get surgeryReason => text().nullable()();
  TextColumn get asaStatus => text().nullable()();
  TextColumn get baselineDataJson => text().nullable()();
  IntColumn get baselineQuality => integer().nullable()();
  BoolColumn get isCalibrated => boolean().withDefault(const Constant(false))();
  TextColumn get calibrationStatus => text().nullable()();
  RealColumn get calibrationErrorBpm => real().nullable()();
  RealColumn get calibrationCorrelation => real().nullable()();
  DateTimeColumn get startedAt => dateTime()();
  DateTimeColumn get surgeryStartedAt => dateTime().nullable()();
  DateTimeColumn get surgeryEndedAt => dateTime().nullable()();
  DateTimeColumn get endedAt => dateTime().nullable()();
  TextColumn get collarPhotoPath => text().nullable()();
  TextColumn get initialPosition => text().nullable()();
  TextColumn get initialAnxiety => text().nullable()();
  TextColumn get initialNotes => text().nullable()();
  TextColumn get syncStatus => text().withDefault(const Constant('pending'))();
  DateTimeColumn get createdAt => dateTime().withDefault(currentDateAndTime)();
  DateTimeColumn get updatedAt => dateTime().withDefault(currentDateAndTime)();
  
  @override
  Set<Column> get primaryKey => {id};
}

/// Local annotations table
class LocalAnnotations extends Table {
  TextColumn get id => text()();
  TextColumn get sessionId => text()();
  DateTimeColumn get timestampUtc => dateTime()();
  IntColumn get elapsedMs => integer()();
  TextColumn get phase => text()();
  TextColumn get category => text()();
  TextColumn get type => text()();
  TextColumn get description => text().nullable()();
  TextColumn get severity => text().withDefault(const Constant('info'))();
  TextColumn get structuredDataJson => text().nullable()();
  TextColumn get voiceNotePath => text().nullable()();
  TextColumn get voiceTranscription => text().nullable()();
  TextColumn get annotatorUserId => text()();
  BoolColumn get isAutoGenerated => boolean().withDefault(const Constant(false))();
  TextColumn get syncStatus => text().withDefault(const Constant('pending'))();
  DateTimeColumn get createdAt => dateTime().withDefault(currentDateAndTime)();
  
  @override
  Set<Column> get primaryKey => {id};
}

/// Local vitals table (batched)
class LocalVitals extends Table {
  IntColumn get id => integer().autoIncrement()();
  TextColumn get sessionId => text()();
  DateTimeColumn get timestampUtc => dateTime()();
  IntColumn get heartRateBpm => integer()();
  IntColumn get respiratoryRateBpm => integer()();
  RealColumn get temperatureC => real()();
  IntColumn get signalQuality => integer()();
  TextColumn get syncStatus => text().withDefault(const Constant('pending'))();
  DateTimeColumn get createdAt => dateTime().withDefault(currentDateAndTime)();
}

/// Sync queue table
class SyncQueue extends Table {
  IntColumn get id => integer().autoIncrement()();
  TextColumn get entityType => text()(); // session, annotation, vitals, media
  TextColumn get entityId => text()();
  TextColumn get action => text()(); // create, update, delete
  TextColumn get dataJson => text()();
  IntColumn get priority => integer().withDefault(const Constant(5))();
  IntColumn get retryCount => integer().withDefault(const Constant(0))();
  TextColumn get lastError => text().nullable()();
  DateTimeColumn get createdAt => dateTime().withDefault(currentDateAndTime)();
  DateTimeColumn get nextRetryAt => dateTime().nullable()();
}

/// Cached animals table
class CachedAnimals extends Table {
  TextColumn get id => text()();
  TextColumn get name => text()();
  TextColumn get species => text()();
  TextColumn get breed => text()();
  RealColumn get ageYears => real()();
  RealColumn get weightKg => real()();
  TextColumn get sex => text()();
  TextColumn get ownerName => text()();
  TextColumn get ownerPhone => text().nullable()();
  TextColumn get clinicId => text()();
  DateTimeColumn get cachedAt => dateTime().withDefault(currentDateAndTime)();
  
  @override
  Set<Column> get primaryKey => {id};
}

// ============================================================
// Database Class
// ============================================================

@DriftDatabase(tables: [
  LocalSessions,
  LocalAnnotations,
  LocalVitals,
  SyncQueue,
  CachedAnimals,
])
class AppDatabase extends _$AppDatabase {
  AppDatabase() : super(_openConnection());
  
  @override
  int get schemaVersion => 1;
  
  // ============================================================
  // Session Operations
  // ============================================================
  
  Future<void> insertSession(LocalSessionsCompanion session) async {
    await into(localSessions).insert(session, mode: InsertMode.insertOrReplace);
  }
  
  Future<LocalSession?> getSession(String id) async {
    return (select(localSessions)..where((s) => s.id.equals(id))).getSingleOrNull();
  }
  
  Future<List<LocalSession>> getPendingSessions() async {
    return (select(localSessions)..where((s) => s.syncStatus.equals('pending'))).get();
  }
  
  Future<void> updateSessionPhase(String id, String phase) async {
    await (update(localSessions)..where((s) => s.id.equals(id))).write(
      LocalSessionsCompanion(
        currentPhase: Value(phase),
        updatedAt: Value(DateTime.now()),
      ),
    );
  }
  
  Future<void> updateSessionSyncStatus(String id, String status) async {
    await (update(localSessions)..where((s) => s.id.equals(id))).write(
      LocalSessionsCompanion(syncStatus: Value(status)),
    );
  }
  
  Future<void> updateSurgeryDetails({
    required String sessionId,
    required String surgeryType,
    required String surgeryReason,
    required String asaStatus,
  }) async {
    await (update(localSessions)..where((s) => s.id.equals(sessionId))).write(
      LocalSessionsCompanion(
        surgeryType: Value(surgeryType),
        surgeryReason: Value(surgeryReason),
        asaStatus: Value(asaStatus),
        updatedAt: Value(DateTime.now()),
      ),
    );
  }
  
  Future<void> updateSessionBaseline({
    required String sessionId,
    required String baselineJson,
    required int qualityScore,
  }) async {
    await (update(localSessions)..where((s) => s.id.equals(sessionId))).write(
      LocalSessionsCompanion(
        baselineDataJson: Value(baselineJson),
        baselineQuality: Value(qualityScore),
        updatedAt: Value(DateTime.now()),
      ),
    );
  }
  
  Future<void> updateSessionCalibration({
    required String sessionId,
    required bool isCalibrated,
    required String calibrationStatus,
    double? errorBpm,
    double? correlation,
  }) async {
    await (update(localSessions)..where((s) => s.id.equals(sessionId))).write(
      LocalSessionsCompanion(
        isCalibrated: Value(isCalibrated),
        calibrationStatus: Value(calibrationStatus),
        calibrationErrorBpm: Value(errorBpm),
        calibrationCorrelation: Value(correlation),
        updatedAt: Value(DateTime.now()),
      ),
    );
  }
  
  Future<void> updateSessionCollar(String sessionId, String collarId) async {
    await (update(localSessions)..where((s) => s.id.equals(sessionId))).write(
      LocalSessionsCompanion(
        collarId: Value(collarId),
        updatedAt: Value(DateTime.now()),
      ),
    );
  }
  
  // ============================================================
  // Annotation Operations
  // ============================================================
  
  Future<void> insertAnnotation(LocalAnnotationsCompanion annotation) async {
    await into(localAnnotations).insert(annotation, mode: InsertMode.insertOrReplace);
  }
  
  Future<List<LocalAnnotation>> getSessionAnnotations(String sessionId) async {
    return (select(localAnnotations)
      ..where((a) => a.sessionId.equals(sessionId))
      ..orderBy([(a) => OrderingTerm.asc(a.timestampUtc)]))
      .get();
  }
  
  Future<List<LocalAnnotation>> getPendingAnnotations() async {
    return (select(localAnnotations)..where((a) => a.syncStatus.equals('pending'))).get();
  }
  
  Future<void> updateAnnotationSyncStatus(String id, String status) async {
    await (update(localAnnotations)..where((a) => a.id.equals(id))).write(
      LocalAnnotationsCompanion(syncStatus: Value(status)),
    );
  }
  
  // ============================================================
  // Vitals Operations
  // ============================================================
  
  Future<void> insertVitals(LocalVitalsCompanion vitals) async {
    await into(localVitals).insert(vitals);
  }
  
  Future<void> insertVitalsBatch(List<LocalVitalsCompanion> vitalsList) async {
    await batch((b) {
      b.insertAll(localVitals, vitalsList);
    });
  }
  
  Future<List<LocalVital>> getPendingVitals({int limit = 100}) async {
    return (select(localVitals)
      ..where((v) => v.syncStatus.equals('pending'))
      ..limit(limit)
      ..orderBy([(v) => OrderingTerm.asc(v.timestampUtc)]))
      .get();
  }
  
  Future<void> markVitalsSynced(List<int> ids) async {
    await (update(localVitals)..where((v) => v.id.isIn(ids))).write(
      const LocalVitalsCompanion(syncStatus: Value('synced')),
    );
  }
  
  Future<void> deleteOldSyncedVitals({int keepDays = 7}) async {
    final cutoff = DateTime.now().subtract(Duration(days: keepDays));
    await (delete(localVitals)
      ..where((v) => v.syncStatus.equals('synced') & v.createdAt.isSmallerThanValue(cutoff)))
      .go();
  }
  
  // ============================================================
  // Sync Queue Operations
  // ============================================================
  
  Future<void> addToSyncQueue(SyncQueueCompanion item) async {
    await into(syncQueue).insert(item);
  }
  
  Future<List<SyncQueueData>> getNextSyncItems({int limit = 10}) async {
    return (select(syncQueue)
      ..where((q) => q.nextRetryAt.isNull() | q.nextRetryAt.isSmallerOrEqualValue(DateTime.now()))
      ..orderBy([
        (q) => OrderingTerm.asc(q.priority),
        (q) => OrderingTerm.asc(q.createdAt),
      ])
      ..limit(limit))
      .get();
  }
  
  Future<void> removeSyncItem(int id) async {
    await (delete(syncQueue)..where((q) => q.id.equals(id))).go();
  }
  
  Future<void> updateSyncItemRetry(int id, String error) async {
    final nextRetry = DateTime.now().add(const Duration(minutes: 5));
    // Get current item to increment retry count
    final item = await (select(syncQueue)..where((q) => q.id.equals(id))).getSingleOrNull();
    final newRetryCount = (item?.retryCount ?? 0) + 1;
    
    await (update(syncQueue)..where((q) => q.id.equals(id))).write(
      SyncQueueCompanion(
        retryCount: Value(newRetryCount),
        lastError: Value(error),
        nextRetryAt: Value(nextRetry),
      ),
    );
  }
  
  Future<int> getSyncQueueCount() async {
    final count = await (selectOnly(syncQueue)..addColumns([syncQueue.id.count()])).getSingle();
    return count.read(syncQueue.id.count()) ?? 0;
  }
  
  // ============================================================
  // Cached Animals Operations
  // ============================================================
  
  Future<void> cacheAnimal(CachedAnimalsCompanion animal) async {
    await into(cachedAnimals).insert(animal, mode: InsertMode.insertOrReplace);
  }
  
  Future<List<CachedAnimal>> searchCachedAnimals(String query) async {
    final lowerQuery = '%${query.toLowerCase()}%';
    return (select(cachedAnimals)
      ..where((a) => a.name.lower().like(lowerQuery) | a.ownerName.lower().like(lowerQuery))
      ..limit(20))
      .get();
  }
  
  Future<CachedAnimal?> getCachedAnimalById(String id) async {
    return (select(cachedAnimals)..where((a) => a.id.equals(id))).getSingleOrNull();
  }
  
  Future<List<CachedAnimal>> getRecentAnimals({int limit = 10}) async {
    return (select(cachedAnimals)
      ..orderBy([(a) => OrderingTerm.desc(a.cachedAt)])
      ..limit(limit))
      .get();
  }
  
  Future<void> clearOldCache({int keepDays = 7}) async {
    final cutoff = DateTime.now().subtract(Duration(days: keepDays));
    await (delete(cachedAnimals)..where((a) => a.cachedAt.isSmallerThanValue(cutoff))).go();
  }
}

// ============================================================
// Database Connection
// ============================================================

LazyDatabase _openConnection() {
  return LazyDatabase(() async {
    final dbFolder = await getApplicationDocumentsDirectory();
    final file = File(p.join(dbFolder.path, 'vetsync.db'));
    return NativeDatabase.createInBackground(file);
  });
}

// ============================================================
// Database Service (GetX wrapper)
// ============================================================

class DatabaseService extends GetxService {
  late AppDatabase _db;
  
  AppDatabase get db => _db;
  
  @override
  void onInit() {
    super.onInit();
    _db = AppDatabase();
  }
  
  @override
  void onClose() {
    _db.close();
    super.onClose();
  }
}
