import 'enums.dart';

/// Annotation model for session events
class Annotation {
  final String? id;
  final String sessionId;
  final DateTime timestampUtc;
  final int elapsedMs;
  final SessionPhase phase;
  final AnnotationCategory category;
  final String type;
  final String? description;
  final AnnotationSeverity severity;
  final Map<String, dynamic>? structuredData;
  final String? voiceNotePath;
  final String? voiceNoteUrl;
  final String? voiceTranscription;
  final String annotatorUserId;
  final bool isAutoGenerated;
  final String? potentialDuplicateOf;
  final DateTime? createdAt;
  final SyncStatus syncStatus;
  
  Annotation({
    this.id,
    required this.sessionId,
    required this.timestampUtc,
    required this.elapsedMs,
    required this.phase,
    required this.category,
    required this.type,
    this.description,
    this.severity = AnnotationSeverity.info,
    this.structuredData,
    this.voiceNotePath,
    this.voiceNoteUrl,
    this.voiceTranscription,
    required this.annotatorUserId,
    this.isAutoGenerated = false,
    this.potentialDuplicateOf,
    this.createdAt,
    this.syncStatus = SyncStatus.pending,
  });
  
  /// Get elapsed time as formatted string
  String get elapsedTimeFormatted {
    final totalSeconds = elapsedMs ~/ 1000;
    final hours = totalSeconds ~/ 3600;
    final minutes = (totalSeconds % 3600) ~/ 60;
    final seconds = totalSeconds % 60;
    
    if (hours > 0) {
      return '${hours}h ${minutes}m ${seconds}s';
    } else if (minutes > 0) {
      return '${minutes}m ${seconds}s';
    }
    return '${seconds}s';
  }
  
  /// Get display title
  String get displayTitle {
    if (description != null && description!.isNotEmpty) {
      return description!;
    }
    return '${category.displayName}: $type';
  }
  
  /// Get timestamp formatted
  String get timeFormatted {
    return '${timestampUtc.hour.toString().padLeft(2, '0')}:'
           '${timestampUtc.minute.toString().padLeft(2, '0')}:'
           '${timestampUtc.second.toString().padLeft(2, '0')}';
  }
  
  /// Check if annotation has voice note
  bool get hasVoiceNote => voiceNotePath != null || voiceNoteUrl != null;
  
  /// Check if synced
  bool get isSynced => syncStatus == SyncStatus.synced;
  
  factory Annotation.fromJson(Map<String, dynamic> json) {
    return Annotation(
      id: json['annotation_id'] as String? ?? json['id'] as String?,
      sessionId: json['session_id'] as String,
      timestampUtc: DateTime.parse(json['timestamp_utc'] as String),
      elapsedMs: json['elapsed_ms'] as int,
      phase: SessionPhase.fromString(json['phase'] as String),
      category: AnnotationCategory.fromString(json['category'] as String),
      type: json['type'] as String,
      description: json['description'] as String?,
      severity: AnnotationSeverity.fromString(json['severity'] as String? ?? 'info'),
      structuredData: json['structured_data'] as Map<String, dynamic>?,
      voiceNotePath: json['voice_note_path'] as String?,
      voiceNoteUrl: json['voice_note_url'] as String?,
      voiceTranscription: json['voice_transcription'] as String?,
      annotatorUserId: json['annotator_user_id'] as String,
      isAutoGenerated: json['is_auto_generated'] as bool? ?? false,
      potentialDuplicateOf: json['potential_duplicate_of'] as String?,
      createdAt: json['created_at'] != null
          ? DateTime.parse(json['created_at'] as String)
          : null,
      syncStatus: SyncStatus.fromString(json['sync_status'] as String? ?? 'synced'),
    );
  }
  
  Map<String, dynamic> toJson() {
    return {
      if (id != null) 'annotation_id': id,
      'session_id': sessionId,
      'timestamp_utc': timestampUtc.toIso8601String(),
      'elapsed_ms': elapsedMs,
      'phase': phase.value,
      'category': category.value,
      'type': type,
      'description': description,
      'severity': severity.value,
      'structured_data': structuredData,
      'voice_note_path': voiceNotePath,
      'voice_note_url': voiceNoteUrl,
      'voice_transcription': voiceTranscription,
      'annotator_user_id': annotatorUserId,
      'is_auto_generated': isAutoGenerated,
      'potential_duplicate_of': potentialDuplicateOf,
      if (createdAt != null) 'created_at': createdAt!.toIso8601String(),
      'sync_status': syncStatus.value,
    };
  }
  
  Annotation copyWith({
    String? id,
    String? sessionId,
    DateTime? timestampUtc,
    int? elapsedMs,
    SessionPhase? phase,
    AnnotationCategory? category,
    String? type,
    String? description,
    AnnotationSeverity? severity,
    Map<String, dynamic>? structuredData,
    String? voiceNotePath,
    String? voiceNoteUrl,
    String? voiceTranscription,
    String? annotatorUserId,
    bool? isAutoGenerated,
    String? potentialDuplicateOf,
    DateTime? createdAt,
    SyncStatus? syncStatus,
  }) {
    return Annotation(
      id: id ?? this.id,
      sessionId: sessionId ?? this.sessionId,
      timestampUtc: timestampUtc ?? this.timestampUtc,
      elapsedMs: elapsedMs ?? this.elapsedMs,
      phase: phase ?? this.phase,
      category: category ?? this.category,
      type: type ?? this.type,
      description: description ?? this.description,
      severity: severity ?? this.severity,
      structuredData: structuredData ?? this.structuredData,
      voiceNotePath: voiceNotePath ?? this.voiceNotePath,
      voiceNoteUrl: voiceNoteUrl ?? this.voiceNoteUrl,
      voiceTranscription: voiceTranscription ?? this.voiceTranscription,
      annotatorUserId: annotatorUserId ?? this.annotatorUserId,
      isAutoGenerated: isAutoGenerated ?? this.isAutoGenerated,
      potentialDuplicateOf: potentialDuplicateOf ?? this.potentialDuplicateOf,
      createdAt: createdAt ?? this.createdAt,
      syncStatus: syncStatus ?? this.syncStatus,
    );
  }
  
  @override
  String toString() => 'Annotation(id: $id, type: $type, category: ${category.value})';
}

/// Predefined annotation types for quick selection
class AnnotationTypes {
  AnnotationTypes._();
  
  // Anesthesia types
  static const List<String> anesthesia = [
    'Induction',
    'Maintenance adjustment',
    'Depth change - Lighter',
    'Depth change - Deeper',
    'Bolus administered',
    'Infusion started',
    'Infusion stopped',
    'Recovery medication',
  ];
  
  // Medication types
  static const List<String> medication = [
    'Analgesic',
    'Antibiotic',
    'Anti-inflammatory',
    'Antiemetic',
    'Fluid bolus',
    'Blood product',
    'Reversal agent',
    'Other medication',
  ];
  
  // Preparation types
  static const List<String> preparation = [
    'IV catheter placed',
    'Intubation',
    'Extubation',
    'Position change',
    'Clip and prep',
    'Draping',
    'Monitoring attached',
    'Warming device',
  ];
  
  // Surgical types
  static const List<String> surgical = [
    'Incision',
    'Closure started',
    'Closure complete',
    'Organ manipulation',
    'Tissue removal',
    'Hemorrhage',
    'Suture placed',
    'Complication',
  ];
  
  // Event types
  static const List<String> event = [
    'Movement detected',
    'Equipment issue',
    'Position adjustment',
    'Staff change',
    'Room interruption',
    'Temperature adjustment',
    'Artifact noted',
  ];
  
  // Recovery types
  static const List<String> recovery = [
    'First movement',
    'Eye reflex present',
    'Swallow reflex',
    'Head lift',
    'Attempting to stand',
    'Standing',
    'Alert and responsive',
    'Transferred to kennel',
  ];
  
  // Behavior types
  static const List<String> behavior = [
    'Vocalizing',
    'Calm',
    'Anxious',
    'Aggressive',
    'Lethargic',
    'Disoriented',
    'Seeking attention',
    'Resting comfortably',
  ];
  
  // Emergency types
  static const List<String> emergency = [
    'Cardiac arrest',
    'Respiratory arrest',
    'CPR initiated',
    'Severe hemorrhage',
    'Anaphylaxis',
    'Equipment failure',
    'Code called',
    'Emergency resolved',
  ];
}
